// solved by DSU
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int N = graph.length;
        DSU dsu = new DSU(N);
        for (int i = 0; i < N; ++i)
            for (int j = i+1; j < N; ++j)
                if (graph[i][j] == 1)
                    dsu.union(i, j);// connect two point i ; j

        int[] count = new int[N];
        for (int node: initial)
            count[dsu.find(node)]++; // root contaning toxic node plus one

        int ans = -1, ansSize = -1;
        for (int node: initial) {
            int root = dsu.find(node);
            if (count[root] == 1) {  // unique color
                int rootSize = dsu.size(root);//get the size of root containing toxic node
                if (rootSize > ansSize) {
                    ansSize = rootSize;//update ans if new toxic root containing more nodes than previous root.
                    ans = node;
                } else if (rootSize == ansSize && node < ans) {// contaning same size of toxic node but occur ealier than ans; because initial is inordered.
                    ansSize = rootSize;//update size
                    ans = node;//update node number
                }
            }
        }

        if (ans == -1) {
            ans = Integer.MAX_VALUE;
            for (int node: initial)
                ans = Math.min(ans, node);
        }
        return ans;
    }
}


class DSU {// Disjoin Set Union
    int[] p, sz;//p = parent sz = size() size is valuable in combine two set to one

    DSU(int N) {
        p = new int[N];
        for (int x = 0; x < N; ++x)
            p[x] = x; //parent of node is node itself

        sz = new int[N];
        Arrays.fill(sz, 1);// size of all the nodes is 1
    }

    public int find(int x) {// find root of node x 
        if (p[x] != x)
            p[x] = find(p[x]);// get the root of node X
        return p[x];
    }

    public void union(int x, int y) {// combine two sets 
        int xr = find(x);
        int yr = find(y);
        p[xr] = yr; //combine x to y    yr is parent of xr
        sz[yr] += sz[xr]; // sz == if i is root how many node follows i
    }

    public int size(int x) {
        return sz[find(x)];// size is store in root 
    }
}
______________________________________________________________Solved BY DFS(Slower)_____________________________________________________________
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        // 1. Color each component.
        // colors[node] = the color of this node.

        int N = graph.length;
        int[] colors = new int[N];
        Arrays.fill(colors, -1);
        int C = 0;

        for (int node = 0; node < N; ++node)
            if (colors[node] == -1)// Node has no color
                dfs(graph, colors, node, C++);// give node a new color and paint uncolored neighbor of node with same color,与Node相连的没有颜色的点都染同一个颜色。

        // 2. Size of each color.
        int[] size = new int[C];
        for (int color: colors)
            size[color]++;

        // 3. Find unique colors.
        int[] colorCount = new int[C];
        for (int node: initial)// find the toix node that cannot be infected by others. If there are two node with same color, removing that node is trivial, because the other one can infect node in the same way. **two node in a circle** so find one node in a circle. 
            colorCount[colors[node]]++; // color of toxic node plus 1 in the toxic node set.

        // 4. Answer
        int ans = Integer.MAX_VALUE;
        for (int node: initial) {
            int c = colors[node];
            if (colorCount[c] == 1) { // unqiue toxic point , only occur once in the toxic node set.
                if (ans == Integer.MAX_VALUE)
                    ans = node;
                else if (size[c] > size[colors[ans]])// color of node is more than color of ans
                    ans = node;//update
                else if (size[c] == size[colors[ans]] && node < ans)//same size, but node occur first. 
                    ans = node;//update ans. 
            }
        }

        if (ans == Integer.MAX_VALUE)//unchanged. all in the circle
            for (int node: initial)
                ans = Math.min(ans, node);//delete the earliest node.

        return ans;
    }

    public void dfs(int[][] graph, int[] colors, int node, int color) { // paint uncolored neighbor of node with same color
        colors[node] = color;//gives node a new color
        for (int nei = 0; nei < graph.length; ++nei)
            if (graph[node][nei] == 1 && colors[nei] == -1)//neighbor has not been colored
                dfs(graph, colors, nei, color);
    }
}
